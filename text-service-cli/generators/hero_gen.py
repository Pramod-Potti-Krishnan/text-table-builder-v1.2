"""
Hero Generator for Text Service CLI

Generates all files needed to integrate a new hero slide type:
- Generator class (app/core/hero/{hero_type}_generator.py)
- Image-enhanced generator (optional) (app/core/hero/{hero_type}_with_image_generator.py)
- Test script (tests/test_{hero_type}.py)
- Route addition snippet (for hero_routes.py)
- Init update snippet (for __init__.py)

Uses Jinja2 templates for code generation.
"""

import json
import re
from pathlib import Path
from typing import Dict, Optional
from jinja2 import Environment, FileSystemLoader


class HeroGenerator:
    """
    Generates integration files for new hero slide types.
    """

    def __init__(self, service_root: Path, templates_dir: Path):
        """
        Initialize generator.

        Args:
            service_root: Path to Text Service v1.2 root
            templates_dir: Path to Jinja2 templates directory
        """
        self.service_root = Path(service_root)
        self.templates_dir = Path(templates_dir)

        # Set up Jinja2 environment
        template_path = self.templates_dir / 'hero'
        if template_path.exists():
            self.jinja_env = Environment(
                loader=FileSystemLoader(str(template_path)),
                trim_blocks=True,
                lstrip_blocks=True
            )
        else:
            self.jinja_env = None

    def generate_all(
        self,
        metadata: Dict,
        prompt_template: str,
        validation_rules: Dict,
        with_image: bool = False
    ) -> Dict[str, str]:
        """
        Generate all integration files.

        Args:
            metadata: Hero type metadata from metadata.json
            prompt_template: LLM prompt template content
            validation_rules: Output validation rules
            with_image: Whether to also generate image-enhanced variant

        Returns:
            Dict mapping file paths to generated content
        """
        generated_files = {}

        hero_type = metadata['hero_type']
        class_name = self._to_class_name(hero_type)

        # Build context for templates
        context = {
            'hero_type': hero_type,
            'class_name': class_name,
            'display_name': metadata.get('display_name', hero_type),
            'description': metadata.get('description', ''),
            'endpoint_path': metadata.get('endpoint_path', hero_type.replace('_', '-')),
            'html_structure': metadata.get('html_structure', {}),
            'character_constraints': metadata.get('character_constraints', {}),
            'prompt_template': self._escape_prompt(prompt_template),
            'validation_rules': validation_rules,
        }

        # 1. Generate hero generator class
        generator_path = f"app/core/hero/{hero_type}_generator.py"
        generated_files[generator_path] = self._generate_hero_generator(context)

        # 2. Generate image-enhanced variant if requested
        if with_image:
            image_generator_path = f"app/core/hero/{hero_type}_with_image_generator.py"
            generated_files[image_generator_path] = self._generate_image_hero_generator(context)

        # 3. Generate test script
        test_path = f"tests/test_{hero_type}.py"
        generated_files[test_path] = self._generate_test_script(context)

        # 4. Generate route addition snippet
        generated_files['_routes_update'] = self._generate_routes_snippet(context, with_image)

        # 5. Generate __init__.py update snippet
        generated_files['_init_update'] = self._generate_init_snippet(context, with_image)

        return generated_files

    def _generate_hero_generator(self, context: Dict) -> str:
        """Generate the hero generator Python class."""
        hero_type = context['hero_type']
        class_name = context['class_name']
        display_name = context['display_name']
        description = context['description']
        endpoint_path = context['endpoint_path']
        char_constraints = context['character_constraints']
        prompt_template = context['prompt_template']
        validation_rules = context['validation_rules']

        # Build validation code
        validation_code = self._build_validation_code(validation_rules, char_constraints)

        generator_code = f'''"""
{display_name} Generator (L29 Hero Layout)

Generated by text-service-cli

{description}

Endpoint: POST /v1.2/hero/{endpoint_path}
Layout: L29 Full-Bleed Hero
Model: Flash (gemini-2.5-flash)
"""

import re
import logging
from typing import Dict, Any

from .base_hero_generator import BaseHeroGenerator, HeroGenerationRequest

logger = logging.getLogger(__name__)


class {class_name}Generator(BaseHeroGenerator):
    """
    {display_name} generator for L29 hero layout.

    {description}
    """

    @property
    def slide_type(self) -> str:
        """Return slide type identifier."""
        return "{hero_type}"

    async def _build_prompt(
        self,
        request: HeroGenerationRequest
    ) -> str:
        """
        Build prompt for {display_name} generation.

        Args:
            request: Hero generation request

        Returns:
            Complete LLM prompt string
        """
        # Extract context
        theme = request.context.get("theme", "professional")
        audience = request.context.get("audience", "general business audience")
        narrative = request.narrative
        topics = request.topics

        prompt = f"""{prompt_template}"""

        return prompt

    def _validate_output(
        self,
        content: str,
        request: HeroGenerationRequest
    ) -> Dict[str, Any]:
        """
        Validate {display_name} content structure.

        Args:
            content: Generated HTML content
            request: Original request for context

        Returns:
            Validation result dictionary
        """
        # Run base validation
        validation = super()._validate_output(content, request)

        violations = validation.get("violations", [])
        warnings = validation.get("warnings", [])
        metrics = validation.get("metrics", {{}})

        # {display_name}-specific validation
{validation_code}

        validation["violations"] = violations
        validation["warnings"] = warnings
        validation["metrics"] = metrics
        validation["valid"] = len(violations) == 0

        return validation
'''

        return generator_code

    def _generate_image_hero_generator(self, context: Dict) -> str:
        """Generate the image-enhanced hero generator Python class."""
        hero_type = context['hero_type']
        class_name = context['class_name']
        display_name = context['display_name']
        description = context['description']
        endpoint_path = context['endpoint_path']

        image_generator_code = f'''"""
{display_name} Generator with AI-Generated Background Images

Generated by text-service-cli

{description}

Endpoint: POST /v1.2/hero/{endpoint_path}-with-image
Layout: L29 Full-Bleed Hero with Background Image
"""

import asyncio
import logging
import re
from typing import Dict, Any

from .{hero_type}_generator import {class_name}Generator
from .base_hero_generator import HeroGenerationRequest
from app.services.image_service_client import (
    get_image_service_client,
    ImageServiceClient,
    SlideType
)

logger = logging.getLogger(__name__)


class {class_name}WithImageGenerator({class_name}Generator):
    """
    {display_name} generator with AI-generated background images.

    Extends {class_name}Generator to add:
    - Contextual background image generation
    - Gradient overlay for text readability
    - Parallel image + content generation
    """

    def __init__(self, llm_service):
        """
        Initialize generator with LLM and Image services.

        Args:
            llm_service: LLM service instance for content generation
        """
        super().__init__(llm_service)
        self.image_client: ImageServiceClient = get_image_service_client()

    @property
    def slide_type(self) -> str:
        """Return slide type identifier."""
        return "{hero_type}_with_image"

    def _build_image_prompt(
        self,
        request: HeroGenerationRequest
    ) -> str:
        """
        Build image generation prompt.

        Args:
            request: Hero generation request

        Returns:
            Image prompt string
        """
        narrative = request.narrative
        topics = request.topics
        theme = request.context.get("theme", "professional")

        prompt = f"""High-quality professional presentation background.

Topic: {{narrative}}
Key themes: {{', '.join(topics[:3]) if topics else 'professional environment'}}
Style: {{theme}}, modern, sophisticated
Composition: Abstract, suitable for text overlay

CRITICAL: NO text, words, letters, or typography in the image."""

        return prompt

    async def generate(
        self,
        request: HeroGenerationRequest
    ) -> Dict[str, Any]:
        """
        Generate {hero_type} with background image.

        Runs image and content generation in parallel.
        Falls back to gradient if image generation fails.

        Args:
            request: Hero generation request

        Returns:
            Generation result with content and image metadata
        """
        logger.info(
            f"Generating {hero_type} with background image "
            f"(slide #{{request.slide_number}})"
        )

        try:
            # Build image prompt
            image_prompt = self._build_image_prompt(request)

            # Start both tasks in parallel
            image_task = asyncio.create_task(
                self._generate_image(image_prompt, request)
            )
            content_task = asyncio.create_task(
                self._generate_content(request)
            )

            # Wait for both to complete
            results = await asyncio.gather(
                image_task,
                content_task,
                return_exceptions=True
            )

            image_result = results[0]
            content_result = results[1]

            # Check for content generation errors
            if isinstance(content_result, Exception):
                logger.error(f"Content generation failed: {{content_result}}")
                raise content_result

            # Handle image result
            background_image = None
            fallback_to_gradient = False
            image_metadata = {{}}

            if isinstance(image_result, Exception):
                logger.warning(
                    f"Image generation failed, using gradient fallback: {{image_result}}"
                )
                fallback_to_gradient = True
            elif image_result and image_result.get("success"):
                background_image = (
                    image_result["urls"].get("cropped") or
                    image_result["urls"]["original"]
                )
                image_metadata = image_result.get("metadata", {{}})
            else:
                fallback_to_gradient = True

            # Build response
            response = {{
                "content": content_result["content"],
                "metadata": {{
                    "slide_type": self.slide_type,
                    "slide_number": request.slide_number,
                    "background_image": background_image,
                    "image_generation_time_ms": image_metadata.get("generation_time_ms"),
                    "fallback_to_gradient": fallback_to_gradient,
                    "validation": content_result.get("validation", {{}}),
                    "generation_mode": "hero_slide_with_image_async"
                }}
            }}

            return response

        except Exception as e:
            logger.error(f"{hero_type} with image generation failed: {{e}}")
            raise

    async def _generate_image(
        self,
        prompt: str,
        request: HeroGenerationRequest
    ) -> Dict[str, Any]:
        """Generate background image."""
        metadata = {{
            "slide_type": "{hero_type}",
            "slide_number": request.slide_number,
            "narrative": request.narrative[:100],
        }}

        return await self.image_client.generate_background_image(
            prompt=prompt,
            slide_type=SlideType.CLOSING,  # Adjust as needed
            metadata=metadata
        )

    async def _generate_content(
        self,
        request: HeroGenerationRequest
    ) -> Dict[str, Any]:
        """Generate HTML content using LLM."""
        prompt = await self._build_prompt(request)
        raw_content = await self.llm_service(prompt)
        content = self._clean_markdown_wrapper(raw_content)
        validation = self._validate_output(content, request)

        return {{
            "content": content,
            "validation": validation
        }}
'''

        return image_generator_code

    def _generate_test_script(self, context: Dict) -> str:
        """Generate test script for the hero type."""
        hero_type = context['hero_type']
        display_name = context['display_name']
        endpoint_path = context['endpoint_path']

        test_script = f'''#!/usr/bin/env python3
"""
Integration test for {display_name} hero generator.

Run with:
    python3 tests/test_{hero_type}.py
"""

import asyncio
import json
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))

import httpx


# Test configuration
API_BASE_URL = "http://localhost:8000"
ENDPOINT = "/v1.2/hero/{endpoint_path}"
OUTPUT_FILE = "test_outputs/test_{hero_type}_output.html"


async def test_{hero_type.replace("-", "_")}():
    """Test {display_name} generation."""
    print(f"Testing {display_name}")
    print("=" * 60)

    # Test request payload
    payload = {{
        "slide_number": 1,
        "slide_type": "{hero_type}",
        "narrative": "Testing the {display_name} hero slide type",
        "topics": ["Test Topic 1", "Test Topic 2", "Test Topic 3"],
        "context": {{
            "theme": "professional",
            "audience": "general business audience",
            "presentation_title": "Test Presentation"
        }}
    }}

    print(f"\\nRequest to: {{ENDPOINT}}")
    print(json.dumps(payload, indent=2))

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{{API_BASE_URL}}{{ENDPOINT}}",
                json=payload
            )

            if response.status_code != 200:
                print(f"\\nError: Status {{response.status_code}}")
                print(response.text)
                return False

            result = response.json()

            # Display results
            print(f"\\nResponse:")
            print(f"  Slide type: {{result.get('metadata', {{}}).get('slide_type')}}")

            # Show validation
            validation = result.get('metadata', {{}}).get('validation', {{}})
            print(f"\\nValidation:")
            print(f"  Valid: {{validation.get('valid')}}")
            if validation.get('violations'):
                print(f"  Violations: {{validation.get('violations')}}")
            if validation.get('warnings'):
                print(f"  Warnings: {{validation.get('warnings')}}")
            if validation.get('metrics'):
                print(f"  Metrics: {{validation.get('metrics')}}")

            # Save HTML output
            html_content = result.get('content', '')
            if html_content:
                output_path = Path(OUTPUT_FILE)
                output_path.parent.mkdir(parents=True, exist_ok=True)
                with open(output_path, 'w') as f:
                    f.write(html_content)
                print(f"\\nHTML saved to: {{OUTPUT_FILE}}")
                print(f"  Size: {{len(html_content)}} characters")

            print("\\n" + "=" * 60)
            is_valid = validation.get('valid', False)
            print("Test PASSED" if is_valid else "Test FAILED")

            return is_valid

    except httpx.ConnectError:
        print(f"\\nError: Could not connect to {{API_BASE_URL}}")
        print("Make sure the Text Service is running:")
        print("  python3 main.py")
        return False
    except Exception as e:
        print(f"\\nError: {{e}}")
        return False


if __name__ == "__main__":
    success = asyncio.run(test_{hero_type.replace("-", "_")}())
    sys.exit(0 if success else 1)
'''

        return test_script

    def _generate_routes_snippet(self, context: Dict, with_image: bool) -> str:
        """Generate route addition snippet for hero_routes.py."""
        hero_type = context['hero_type']
        class_name = context['class_name']
        display_name = context['display_name']
        endpoint_path = context['endpoint_path']

        snippet = f'''
# Add to app/api/hero_routes.py:

# 1. Add import at top of file:
from ..core.hero import {class_name}Generator
'''

        if with_image:
            snippet += f'''from ..core.hero import {class_name}WithImageGenerator
'''

        snippet += f'''

# 2. Add dependency function:
def get_{hero_type}_generator(
    llm_service: Callable = Depends(get_async_llm_service)
) -> {class_name}Generator:
    """Create {class_name}Generator instance."""
    return {class_name}Generator(llm_service)

'''

        if with_image:
            snippet += f'''
def get_{hero_type}_with_image_generator(
    llm_service: Callable = Depends(get_async_llm_service)
) -> {class_name}WithImageGenerator:
    """Create {class_name}WithImageGenerator instance."""
    return {class_name}WithImageGenerator(llm_service)

'''

        snippet += f'''
# 3. Add route:
@router.post("/{endpoint_path}", response_model=HeroGenerationResponse)
async def generate_{hero_type}(
    request: HeroGenerationRequest,
    generator: {class_name}Generator = Depends(get_{hero_type}_generator)
) -> HeroGenerationResponse:
    """
    Generate {display_name} (L29 hero layout).

    {context['description']}
    """
    try:
        logger.info(f"Generating {hero_type} (slide #{{request.slide_number}})")
        result = await generator.generate(request)
        logger.info(f"{display_name} generated successfully")
        return result

    except ValueError as e:
        logger.error(f"Validation error in {hero_type} generation: {{e}}")
        raise HTTPException(
            status_code=400,
            detail=f"{display_name} validation failed: {{str(e)}}"
        )

    except Exception as e:
        logger.error(f"{display_name} generation failed: {{e}}")
        raise HTTPException(
            status_code=500,
            detail=f"{display_name} generation failed: {{str(e)}}"
        )
'''

        if with_image:
            snippet += f'''

# 4. Add image-enhanced route:
@router.post("/{endpoint_path}-with-image", response_model=HeroGenerationResponse)
async def generate_{hero_type}_with_image(
    request: HeroGenerationRequest,
    generator: {class_name}WithImageGenerator = Depends(get_{hero_type}_with_image_generator)
) -> HeroGenerationResponse:
    """
    Generate {display_name} with AI-generated background image.
    """
    try:
        logger.info(f"Generating {hero_type} with image (slide #{{request.slide_number}})")
        result = await generator.generate(request)
        return result
    except Exception as e:
        logger.error(f"{display_name} with image generation failed: {{e}}")
        raise HTTPException(
            status_code=500,
            detail=f"{display_name} with image generation failed: {{str(e)}}"
        )
'''

        return snippet

    def _generate_init_snippet(self, context: Dict, with_image: bool) -> str:
        """Generate __init__.py update snippet."""
        hero_type = context['hero_type']
        class_name = context['class_name']

        snippet = f'''
# Add to app/core/hero/__init__.py:

# 1. Add import:
from .{hero_type}_generator import {class_name}Generator
'''

        if with_image:
            snippet += f'''from .{hero_type}_with_image_generator import {class_name}WithImageGenerator
'''

        snippet += f'''

# 2. Add to __all__ list:
__all__ = [
    # ... existing exports ...
    "{class_name}Generator",
'''

        if with_image:
            snippet += f'''    "{class_name}WithImageGenerator",
'''

        snippet += f''']
'''

        return snippet

    def _build_validation_code(
        self,
        validation_rules: Dict,
        char_constraints: Dict
    ) -> str:
        """Build validation code from rules."""
        code_lines = []

        # Required elements validation
        required_elements = validation_rules.get('required_elements', [])
        if required_elements:
            code_lines.append("        # Check for required HTML elements")
            for elem in required_elements:
                tag = elem.get('tag', 'div')
                style_contains = elem.get('style_contains', '')
                class_pattern = elem.get('class_pattern', '')

                if style_contains:
                    code_lines.append(f'''        if not re.search(r'<{tag}[^>]*style=[^>]*{style_contains}', content, re.IGNORECASE):
            warnings.append("Missing {tag} with {style_contains} style")''')
                elif class_pattern:
                    code_lines.append(f'''        if not re.search(r'<{tag}[^>]*class=[^>]*{class_pattern}', content, re.IGNORECASE):
            warnings.append("Missing {tag} with {class_pattern} class")''')
                else:
                    code_lines.append(f'''        if '<{tag}' not in content.lower():
            warnings.append("Missing {tag} element")''')

        # Character constraints validation
        if char_constraints:
            code_lines.append("")
            code_lines.append("        # Check character constraints")
            for field, limits in char_constraints.items():
                min_chars = limits.get('min', 0)
                max_chars = limits.get('max', 999)
                code_lines.append(f'''        # {field}: {min_chars}-{max_chars} chars
        # Note: Implement character extraction for {field} as needed''')

        # Forbidden patterns validation
        forbidden = validation_rules.get('forbidden_patterns', [])
        if forbidden:
            code_lines.append("")
            code_lines.append("        # Check for forbidden patterns (handled by base class)")

        if not code_lines:
            code_lines.append("        # No additional validation rules defined")
            code_lines.append("        pass")

        return '\n'.join(code_lines)

    def _escape_prompt(self, prompt: str) -> str:
        """Escape prompt template for embedding in Python string."""
        # Escape triple quotes and backslashes
        escaped = prompt.replace('\\', '\\\\')
        escaped = escaped.replace('"""', '\\"\\"\\"')
        # Replace single { and } with double for f-string safety (except template vars)
        # This is tricky - keep template vars like {narrative} but escape literal braces
        return escaped

    def _to_class_name(self, snake_case: str) -> str:
        """Convert snake_case to PascalCase."""
        return ''.join(word.capitalize() for word in snake_case.split('_'))


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python hero_gen.py <input_dir>")
        sys.exit(1)

    input_dir = Path(sys.argv[1])

    with open(input_dir / 'metadata.json') as f:
        metadata = json.load(f)

    with open(input_dir / 'prompt_template.md') as f:
        prompt_template = f.read()

    validation_rules = {}
    rules_path = input_dir / 'validation_rules.json'
    if rules_path.exists():
        with open(rules_path) as f:
            validation_rules = json.load(f)

    generator = HeroGenerator(
        Path.cwd().parent,
        Path(__file__).parent.parent / 'templates'
    )

    files = generator.generate_all(
        metadata, prompt_template, validation_rules,
        with_image=True
    )

    print(f"Generated {len(files)} files:")
    for path in files:
        if not path.startswith('_'):
            print(f"  {path}")
